Title         : Simple Ruby Callbacks
Tags          : ruby
Publish Date  : 2011-11-27 20:38:19
Author        : Matt Sears

Callbacks are a great technique for achieving power and flexibility in your Ruby applications. Simply put, a callback is a block of code passed as an argument to other methods, which decides when to call the block of code during some point in its operation. So, if you want some code to be executed as soon as the result is ready, you put that code into a method and pass that method as the callback argument.

Ruby makes it trivial to pass a block of code into our method calls. But what do we do when a method needs two blocks of code or more? Consider the classic case where we want a method to execute a specific piece of code if an action succeeds or call different code if an action fails.

In this article, I will show you how we can pass multiple blocks to a method and with some metaprogramming, we can achieve a simple callback mechanism with just a few lines of code.

Let's add a method called `callback` to the Proc class:

```ruby
class Proc
  def callback(callable, *args)
    self === Class.new do
      method_name = callable.to_sym
      define_method(method_name) { |&block| block.nil? ? true : block.call(*args) }
      define_method("#{method_name}?") { true }
      def method_missing(method_name, *args, &block) false; end
    end.new
  end
end
```

That's it! The above method simply yields an anonymous Class with methods defined to handle our callbacks. The first `define_method` will call the block if a block exists, otherwise true is returned. Undefined methods always return false.

Notice we're using the `===` operand to invoke the block. `Proc#===` is an alias for Proc.call. Anything on the right side of `===` acts as the proc's parameter. Normally, this is to allow a proc object to be a target of a `when` clause in case statements, but here we're using it as a super simple way of invoking our anonymous class.

Let’s try it with something useful. Let’s say we’re writing something which
needs to happen in an all-or-nothing, atomic fashion. Either the whole thing
works, or none of it does.  A simple case is tweeting:

```ruby
def tweet(message, &block)
  Twitter.update(message)
  block.callback :success
rescue => e
  block.callback :failure, e.message
end
```

The `tweet` method accepts a message string and &block parameters. We call `callback` on the block and give it a name. Any name will work :success, :error, :fail!, etc. In addition, we can pass arguments to the blocks (more on that later). Now we can provide a status if the tweet was successful or not:

```ruby
tweet "Ruby methods with multiple blocks. #lolruby" do |on|
  on.success do
    puts "Tweet successful!"
  end
  on.failure do |status|
    puts "Error: #{status}"
  end
end
```

The advantage here is that we define our own mini DSL. We don't need to worry
about passing too many or unexpected blocks. We could have easily said `where.success` or `on.error` or `update.fail!`. Also note the `on.failure`
block includes a `status` parameter - this contains the exception message
captured in the `tweet` method above. So if Twitter was down for whatever
reason, the `on.failure` block would be invoked and printed 'Error: Twitter is
down or being upgraded'.

Bonus: In addition to wrapping code in blocks, our `Proc#callback` method defines boolean style methods. So we could have call the tweet method like this if we wanted to:

```ruby
tweet "Ruby methods with multiple blocks. #lolruby" do |update|
  puts "Tweet successful!" if update.success?
  puts "Sorry, something went wrong." if update.failure?
end
```

Put the `Proc#callback` method in a utility library and your code will look neat and tidy.