Title         : Simple Callbacks in Ruby
Tags          : ruby
Publish Date  : 2011-12-13 20:38:19
Author        : Matt Sears

Ruby blocks rock. They're so great, sometimes we want to pass multiple blocks to
a method, but, Ruby doesn't allow this. Consider the classic example where we
want to perform a block of code if an action succeeds and perform different code
if an action fails.

Fortunately, Ruby provides us the ability to modify itself. So with a couple
lines of code we can achieve the above situation. In this case, let's add a
method called `perform` to the Proc class:

```ruby
class Proc
  def perform(callable, *args)
    self === Class.new do
      method_name = callable.to_sym
      define_method(method_name) { |&block| block.nil? ? true : block.call(*args) }
      define_method("#{method_name}?") { true }
      def method_missing(method_name, *args, &block) false; end
    end.new
  end
end
```

The above method simply yields an anonymous Class with methods defined to handle
our callbacks. The first `define_method` will simply call the block if a block
exists, otherwise true is returned. Undefined methods always return false.

Notice we're using the `===` operand to invoke the block. Anything on the right side
of `===` acts as the proc's parameter like `Proc#call`.  Normally, this is to
allow a proc object to be a target of a `when` clause in case statements, but
here we're using it as a super simple way of invoking our anonymous class.

Let’s try it with something useful. Let’s say we’re writing something which
needs to happen in an all-or-nothing, atomic fashion. Either the whole thing
works, or none of it does.  A simple case is tweeting:

```ruby
def tweet(message, &block)
  Twitter.update(message)
  block.perform :success
rescue => e
  block.perform :failure, e.message
end
```

The `tweet` method accepts a message string and &block parameters. We call `perform` on
the block and give it a name. Any name will work :success, :error, :fail!, etc. In addition, we can pass
arguments to the blocks (more on that later). Now we can provide a status if the tweet was successful
or not:


```ruby
tweet "Ruby methods with multiple blocks. #lolruby" do |on|
  on.success do
    puts "Tweet successful!"
  end
  on.failure do |status|
    puts "Error: #{status}"
  end
end
```

The cool thing here is that we can define our own DSL. We don't need to worry
about passing too many or unexpected blocks. We could have easily
said `where.success` or `on.error` or `update.fail!`. Also note the `on.failure`
block includes a `status` parameter - this contains the exception message
captured in the `tweet` method above. So if Twitter was down for whatever
reason, the `on.failure` block would be invoked and printed 'Error: Twitter is
down or being upgraded'.

Bonus: In addition to wrapping code in blocks, our `Proc#perform` method defines
boolean style methods. So we could have call the tweet method like this if we
wanted to:

```ruby
tweet "Ruby methods with multiple blocks. #lolruby" do |update|
  puts "Tweet successful!" if update.success?
  puts "Sorry, something went wrong." if update.failure?
end
```

Procs are a fantastic Ruby concept and make the language much more
expressive. When combined with good syntax highlighting, they also help
differentiate code from strings. Unfortunately, they’re only going to get more
confusing for newbies.
